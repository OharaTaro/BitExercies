#include <iostream>
#include <bitset>

// ビット演算基礎

int main()
{
	////////////////////////////////////////////////////////////////////////////
	// 基数変換
	////////////////////////////////////////////////////////////////////////////
	// 10進数:	8
	// 16進数:	0x00000008
	// 2進数:	0000 0000 0000 0000 0000 0000 0000 1000		// スペースは見やすくするために入れているだけ
	uint32_t test = 8;

	////////////////////////////////////////////////////////////////////////////
	// データの出力
	////////////////////////////////////////////////////////////////////////////

	// 何もしなければ10進表記
	std::cout << "10進:" << test << std::endl;
	std::cout << "**************************" << std::endl;

	// 16進表記の前に0x,8進表記の前に0を追加する
	std::cout << std::showbase;

	// 出力時の基数を指定可能
	std::cout << "16進:" << std::hex << test << std::endl; // 16進数
	std::cout << "10進:" << std::dec << test << std::endl; // 10進数
	std::cout << "8進:" << std::oct << test << std::endl; // 8進数
	// bitsetで2進数表記可能
	// <bitset>のincludeが必要
	// std::bitset<XX>	のXXにはビット数を入れる
	std::cout << "2進:" << std::bitset<32>(test) << std::endl; // 00001001 (2進数)

	// 16進表記の前に0x,8進表記の前に0を追加するのをやめる
	std::cout << std::noshowbase;

	// 基本の出力を10進に戻す
	std::cout << std::dec;

	std::cout << "**************************" << std::endl;

	////////////////////////////////////////////////////////////////////////////
	// ビット演算基本操作
	////////////////////////////////////////////////////////////////////////////

	// 0bから始めることで2進数で数値の指定ができる
	// 0xから始めた場合は16進数
	uint16_t test2 = 0b1010101010101010;
	uint16_t test3 = 0x00ff;				// 0b0000000011111111

	// or演算	演算子:|
	// 各ビットごとに演算を行い、どちらかのビットが1なら1が出力される
	std::cout << "OR :" << std::bitset<16>(test2 | test3) << std::endl;

	// and演算	演算子:&
	// 各ビットごとに演算を行い、両方のビットが1なら1が出力される
	std::cout << "AND:" << std::bitset<16>(test2 & test3) << std::endl;

	// ビット反転	演算子:~
	// 各ビットの0を1に、1を0にする
	std::cout << "NOT:" << std::bitset<16>(~test3) << std::endl;

	// xor演算	演算子:^
	// 各ビットごとに演算を行い、両方のビットが同じなら0、違う場合1を出力する
	std::cout << "XOR:" << std::bitset<16>(test2 ^ test3) << std::endl;

	// 左シフト	演算子:<<
	// 各ビットを左に指定された数だけずらす
	// 空いた部分は0で埋められる
	std::cout << "左S:" << std::bitset<16>(test3 << 2) << std::endl;	// 左に2ビットシフト

	// 右シフト	演算子:>>
	// 各ビットを右に指定された数だけずらす
	// 空いた部分は0で埋められる
	std::cout << "右S:" << std::bitset<16>(test2 >> 4) << std::endl;	// 右に4ビットシフト

	std::cout << "**************************" << std::endl;

	////////////////////////////////////////////////////////////////////////////
	// ビット演算応用
	////////////////////////////////////////////////////////////////////////////
	uint16_t test4 = 0;			// 0b0000000000000000
	uint16_t test5 = 0x000f;	// 0b0000000000001111


	// ex0.指定したビットに1を立てる
	std::cout << "指定したビットに1を立てる" << std::endl;

	int shift = 5;	// 右から5個目のビットを立てる
	test4 |= (1 << (shift-1));	// 一番右のビットは0個目なので-1する
								// +=などと同様に |= , <<= なども可能
	std::cout << "ex0:" << std::bitset<16>(test4) << std::endl;

	shift = 10;	// さらに右から10個目のビットも立てる
	test4 |= (1 << (shift - 1));
	std::cout << "ex0:" << std::bitset<16>(test4) << std::endl;


	// ex1.特定のビットが1かどうかをチェックする
	std::cout << "特定のビットが1かどうかをチェックする" << std::endl;
	test4 = 0b1010101010101010;
	// for文を使って全ビットをチェックする
	for (int i = 0; i < 16; i++)
	{
		// チェック用のデータを生成
		// i=0:	temp = 0b0000000000000001;
		// i=1:	temp = 0b0000000000000010;
		// i=2:	temp = 0b0000000000000100;	...と続く
		uint16_t temp = 0x0000 | (1 << i);

		// 生成されたtempとチェックしたいデータのand演算
		// tempのチェックしたいビット以外は0なので必ず0になる
		// tempのチェックしたいビットは1なのでtest4の同じビットが0なら0、1なら1が出力される
		// チェックしたいビットのみ立てたデータ(今回はtemp)をビットマスクと読んだりする
		if (test4 & temp)
		{
			std::cout << "右から" << i << "ビット目:" << std::endl;
		}
	}



	return 0;
}